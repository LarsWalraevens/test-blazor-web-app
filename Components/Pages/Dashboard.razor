@page "/dashboard"
@using CustomDashboard.Components
@using Microsoft.AspNetCore.Components
@using System.Collections.ObjectModel
@using Newtonsoft.Json
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<PageTitle>Custom dashboard</PageTitle>
<style>
    .grid-item {
        min-width: 300px;
        min-height: 150px;
    }
</style>

<h1 class="mb-4">Custom dashboard
    <span class="btn btn-primary" @onclick="ToggleEditing">
        <i class="bi bi-pencil mr-2" />
        @(!Instance.IsEditing ? "Edit" : "Stop editing")
    </span>
</h1>
@if (Instance != null && Instance.Items != null)
{
    <div class="grid-container" style="display: grid; grid-template-columns: repeat(@Instance.MaxX, 1fr); gap: 5px;">
        @foreach (var item in Instance.Items)
        {
            <div class="grid-item" style="@GenerateGridItemStyles(item)">
                @if (Instance.IsEditing && item.IsAvailable)
                {

                    <div class="card relative"
                        style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
                        <AddWidgetToCustomDashboard Instance="@Instance" Item="@item"
                            OnSuccess="@(async (e) => { StateHasChanged(); })" />
                    </div>
                }
                else
                {
                    <div class="card @(item.IsAvailable == true && Instance.IsEditing == false ? "opacity-0" : null)"
                        style="width: 100%; height: 100%;">
                        <div class="card-body">
                            <h5 class="card-title no-select">@item.Name</h5>
                            @if (Instance.IsEditing)
                            {
                                <div style="position: absolute; top: 0; right: 0;">
                                    @* <span
                    class="badge @(SelectedIndex.HasValue && SelectedIndex == Instance.Items.IndexOf(item) ?
                    "bg-primary" : "bg-secondary")">
                    @if (SelectedIndex.HasValue && SelectedIndex == Instance.Items.IndexOf(item))
                    {
                    <i title="Switch positions" class="bi bi-arrow-left-right" @onclick="ResetSelectedIndex"
                    style="cursor:pointer;"> Selected</i>
                    }
                    else
                    {
                    <i title="Switch positions" class="bi bi-arrow-left-right" style="cursor:pointer;"
                    @onclick="@(() => ClickItem(item))">
                    @if (SelectedIndex.HasValue && SelectedIndex != Instance.Items.IndexOf(item))
                    {
                    @: Switch Positions with
                    }
                    </i>
                    }
                    </span> *@
                                    <span class="badge bg-primary" style="cursor: pointer;">
                                        <i title="Delete" class="bi bi-trash" @onclick="() => DeleteItemAsync(item)"></i>
                                    </span>
                                </div>
                            }
                        </div>
                    </div>
                }
            </div>
        }
    </div>

    <pre style="max-width: 80vw; margin: 5rem 0">@JsonConvert.SerializeObject(Instance, Formatting.Indented)</pre>
}

@code {
    public CustomDashboardInstance Instance { get; set; } = new CustomDashboardInstance()
        {
            IsEditing = false
        };

    private int? SelectedIndex { get; set; }
    private string GenerateGridItemStyles(CustomDashboardItem item)
    {
        // Calculate the start and end positions for the CSS grid
        int gridColumnStart = item.Position.X + 1; // Convert to 1-based index for CSS grid-column
        int gridRowStart = item.Position.Y + 1; // Convert to 1-based index for CSS grid-row
        int gridColumnEnd = Math.Min(gridColumnStart + item.Size.X - 1, Instance.MaxX);
        int gridRowEnd = Math.Min(gridRowStart + item.Size.Y - 1, Instance.MaxY);

        // Ensure the item stays within the grid boundaries
        if (gridColumnStart > Instance.MaxX || gridRowStart > Instance.MaxY)
        {
            // If the item is out of bounds, hide it (you can adjust this logic as needed)
            return "display: none;";
        }

        return $"grid-column: {gridColumnStart} / {gridColumnEnd + 1}; grid-row: {gridRowStart} / {gridRowEnd + 1};";
    }


    private void SwapItems(int index1, int index2)
    {
        CustomDashboardItem item1 = Instance.Items[index1];
        CustomDashboardItem item2 = Instance.Items[index2];

        (int X, int Y) tempPosition = item1.Position;
        item1.Position = item2.Position;
        item2.Position = tempPosition;

        StateHasChanged();
    }

    private void ClickItem(CustomDashboardItem item)
    {
        if (SelectedIndex.HasValue)
        {
            SwapItems(SelectedIndex.Value, Instance.Items.IndexOf(item));
            ResetSelectedIndex();
        }
        else
        {
            SelectedIndex = Instance.Items.IndexOf(item);
        }
    }

    private async Task DeleteItemAsync(CustomDashboardItem item)
    {
        try
        {
            if (item == null) return;

            (int x, int y) position = item.Position;
            (int width, int height) size = item.Size;

            List<CustomDashboardItem> itemsToAdd = new List<CustomDashboardItem>();

            for (int i = position.x; i < position.x + size.width; i++)
            {
                for (int j = position.y; j < position.y + size.height; j++)
                {
                    // Ensure the new item is within the grid boundaries
                    if (i < Instance.MaxX && j < Instance.MaxY)
                    {
                        // Add a new item at each position previously occupied by the deleted item
                        CustomDashboardItem newItem = new CustomDashboardItem
                            {
                                Id = Guid.NewGuid(),
                                Position = (i, j),
                                Size = (1, 1),
                                Name = string.Empty,
                                IsAvailable = true
                            };
                        itemsToAdd.Add(newItem);
                    }
                }
            }

            // Add new items to the collection
            foreach (var newItem in itemsToAdd)
            {
                Instance.Items.Add(newItem);
            }

            // Remove the item from the collection
            Instance.Items.Remove(item);

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            throw new Exception("Error deleting item", ex);
        }
    }

    private void ResetSelectedIndex()
    {
        SelectedIndex = null;
    }

    private void ToggleEditing()
    {
        Instance.IsEditing = !Instance.IsEditing;
        StateHasChanged();
    }

    private void ClickEmptyCell(int x, int y)
    {
        if (SelectedIndex.HasValue)
        {
            CustomDashboardItem itemToMove = Instance.Items[SelectedIndex.Value];
            itemToMove.Position = (x, y);
            ResetSelectedIndex();
            StateHasChanged();
        }
    }
}
